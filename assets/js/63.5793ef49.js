(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{484:function(e,t,a){"use strict";a.r(t);var r=a(2),s=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"vue2和vue3双向数据绑定原理发生了改变"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue2和vue3双向数据绑定原理发生了改变"}},[e._v("#")]),e._v(" vue2和vue3双向数据绑定原理发生了改变")]),e._v(" "),t("p",[e._v("vue是根据Object.defineProperty进行实现的 但是Object.defineProperty只能监听 指定对象的指定属性性的getter和setter行为\n在某些情况下会出现一下问题 比如在data里面声明了一个对象person 为person新增了新的属性 那么这个属性就会失去响应性\nvue2 就提供了vue.$set来解决这个问题所以在Vue3 中引入了反射和代理 可以利用proxy 代理一个对象 但是proxy只能代理一个普通的对象\n所以 vue提供了ref方法")]),e._v(" "),t("h3",{attrs:{id:"是否支持碎片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#是否支持碎片"}},[e._v("#")]),e._v(" 是否支持碎片")]),e._v(" "),t("p",[e._v("Vue2 不支持碎片。Vue3 支持碎片，就是说可以拥有多个根节点")]),e._v(" "),t("h3",{attrs:{id:"api-类型不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#api-类型不同"}},[e._v("#")]),e._v(" API 类型不同")]),e._v(" "),t("p",[e._v("Vue2 使用选项类型api,选项型api 在代码里分割了不同的属性：data,computed,method等。")]),e._v(" "),t("p",[e._v("Vue3 使用合成型api,新的合成型api 能让我们使用方法来分割，相比于旧的api 使用属性来分组，这样代码会更加简便和整洁。")])])}),[],!1,null,null,null);t.default=s.exports}}]);