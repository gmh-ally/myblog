(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{471:function(e,r,t){"use strict";t.r(r);var s=t(2),o=Object(s.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"promisea-规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promisea-规范"}},[e._v("#")]),e._v(" PromiseA+规范")]),e._v(" "),r("h2",{attrs:{id:"_1-相关术语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-相关术语"}},[e._v("#")]),e._v(" 1. 相关术语")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("promise 是一个有then方法的对象或者是函数")])]),e._v(" "),r("li",[r("p",[e._v("thenable 是一个有then方法的对象或者是函数")])]),e._v(" "),r("li",[r("p",[e._v("value 是promise状态成功时的值，也就是resolve的参数, 包括各种数据类型, 也包括undefined/thenable或者是 promise")])]),e._v(" "),r("li",[r("p",[e._v("reason 是promise状态失败时的值, 也就是reject的参数, 表示拒绝的原因")])]),e._v(" "),r("li",[r("p",[e._v("exception 是一个使用throw抛出的异常值")])])]),e._v(" "),r("h2",{attrs:{id:"_2-promisea-规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-promisea-规范"}},[e._v("#")]),e._v(" 2. promiseA+规范")]),e._v(" "),r("h3",{attrs:{id:"_2-1-promise-states"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-promise-states"}},[e._v("#")]),e._v(" 2.1 Promise States")]),e._v(" "),r("p",[e._v("Promise应该有三种状态，要注意他们之间的流转关系.")]),e._v(" "),r("ol",[r("li",[e._v("pending")])]),e._v(" "),r("p",[e._v("初始的状态, 可改变.\n一个promise在resolve或者reject前都处于这个状态。\n可以通过 resolve改变状态，使之变为fulfilled 状态;\n可以通过 reject改变状态，使之变为rejected 状态;")]),e._v(" "),r("ol",{attrs:{start:"2"}},[r("li",[e._v("fulfilled")])]),e._v(" "),r("p",[e._v("最终态, 不可变.\n一个promise被resolve后会变成这个状态.\n必须拥有一个value值")]),e._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[e._v("rejected")])]),e._v(" "),r("p",[e._v("最终态, 不可变.\n一个promise被reject后会变成这个状态\n必须拥有一个reason\nTips: 总结一下, 就是promise的状态流转是这样的")]),e._v(" "),r("p",[e._v("pending——resolve(value)——fulfilled")]),e._v(" "),r("p",[e._v("pending——reject(reason)——rejected")]),e._v(" "),r("p",[e._v("看一下图, 可能会更清晰一点")]),e._v(" "),r("p",[r("img",{attrs:{src:"/myblog/images/js/Promise.png",alt:"Promise 状态流转"}})]),e._v(" "),r("h2",{attrs:{id:"_3-then"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-then"}},[e._v("#")]),e._v(" 3. then")]),e._v(" "),r("p",[e._v("Promise应该提供一个then方法, 用来访问最终的结果, 无论是value还是reason.")]),e._v(" "),r("p",[e._v("promise.then(onFulfilled, onRejected)")]),e._v(" "),r("h3",{attrs:{id:"_1-参数要求"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-参数要求"}},[e._v("#")]),e._v(" 1. 参数要求")]),e._v(" "),r("p",[e._v("onFulfilled 必须是函数类型, 如果不是函数, 应该被忽略.\nonRejected 必须是函数类型, 如果不是函数, 应该被忽略.")]),e._v(" "),r("h3",{attrs:{id:"_2-onfulfilled-特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-onfulfilled-特性"}},[e._v("#")]),e._v(" 2. onFulfilled 特性")]),e._v(" "),r("p",[e._v("在promise变成 fulfilled 时，应该调用onFulfilled, 参数是value\n在promise变成 fulfilled 之前, 不应该被调用.\n只能被调用一次(所以在实现的时候需要一个变量来限制执行次数)")]),e._v(" "),r("h3",{attrs:{id:"_3-onrejected-特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-onrejected-特性"}},[e._v("#")]),e._v(" 3. onRejected 特性")]),e._v(" "),r("p",[e._v("在promise变成 rejected 时，应该调用onRejected, 参数是reason\n在promise变成 rejected 之前, 不应该被调用.\n只能被调用一次(所以在实现的时候需要一个变量来限制执行次数)")]),e._v(" "),r("h3",{attrs:{id:"_4-onfulfilled-和-onrejected-应该是微任务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-onfulfilled-和-onrejected-应该是微任务"}},[e._v("#")]),e._v(" 4. onFulfilled 和 onRejected 应该是微任务")]),e._v(" "),r("p",[e._v("这里用queueMicrotask来实现微任务的调用.")]),e._v(" "),r("h3",{attrs:{id:"_5-then方法可以被调用多次"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-then方法可以被调用多次"}},[e._v("#")]),e._v(" 5. then方法可以被调用多次")]),e._v(" "),r("p",[e._v("promise状态变成 fulfilled 后，所有的 onFulfilled 回调都需要按照then的顺序执行, 也就是按照注册顺序执行(所以在实现的时候需要一个数组来存放多个onFulfilled的回调)\npromise状态变成 rejected 后，所有的 onRejected 回调都需要按照then的顺序执行, 也就是按照注册顺序执行(所以在实现的时候需要一个数组来存放多个onRejected的回调)")]),e._v(" "),r("h3",{attrs:{id:"_6-返回值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-返回值"}},[e._v("#")]),e._v(" 6. 返回值")]),e._v(" "),r("p",[e._v("then 应该返回一个promise")]),e._v(" "),r("p",[e._v("promise2 = promise1.then(onFulfilled, onRejected);\nonFulfilled 或 onRejected 执行的结果为x, 则调用resolvePromise( 下面会详细讲解resolvePromise是什么？ )\n如果 onFulfilled 或者 onRejected 执行时抛出异常e, promise2需要被reject\n如果 onFulfilled 不是一个函数, promise2 以promise1的value 触发fulfilled\n如果 onRejected 不是一个函数, promise2 以promise1的reason 触发rejected")]),e._v(" "),r("h3",{attrs:{id:"_7-resolvepromise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-resolvepromise"}},[e._v("#")]),e._v(" 7. resolvePromise")]),e._v(" "),r("p",[e._v("resolvePromise(promise2, x, resolve, reject)")]),e._v(" "),r("h3",{attrs:{id:"_7-1-如果-promise2-和-x-相等-那么-reject-typeerror"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-如果-promise2-和-x-相等-那么-reject-typeerror"}},[e._v("#")]),e._v(" 7.1 如果 promise2 和 x 相等，那么 reject TypeError")]),e._v(" "),r("h3",{attrs:{id:"_7-2-如果-x-是一个-promsie"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-如果-x-是一个-promsie"}},[e._v("#")]),e._v(" 7.2 如果 x 是一个 promsie")]),e._v(" "),r("p",[e._v("如果x是pending态，那么promise必须要在pending,直到 x 变成 fulfilled or rejected.\n如果 x 被 fulfilled, fulfill promise with the same value.\n如果 x 被 rejected, reject promise with the same reason.")]),e._v(" "),r("h3",{attrs:{id:"_7-3-如果-x-是一个-object-或者-是一个-function"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-如果-x-是一个-object-或者-是一个-function"}},[e._v("#")]),e._v(" 7.3 如果 x 是一个 object 或者 是一个 function")]),e._v(" "),r("p",[e._v("let then = x.then.\n如果 x.then 这步出错，那么 reject promise with e as the reason.")]),e._v(" "),r("p",[e._v("如果 then 是一个函数，")]),e._v(" "),r("p",[e._v("then.call(x, resolvePromiseFn, rejectPromise)\nresolvePromiseFn的入参是y, 执行")]),e._v(" "),r("p",[e._v("resolvePromise(promise2, y, resolve, reject);\nrejectPromise的入参是 r, reject promise with r.")]),e._v(" "),r("p",[e._v("如果 resolvePromise 和 rejectPromise 都调用了，那么第一个调⽤优先，后面的调用忽略。")]),e._v(" "),r("p",[e._v("如果调用then抛出异常e")]),e._v(" "),r("p",[e._v("如果 resolvePromise 或 rejectPromise 已经被调用，那么忽略\n则，reject promise with e as the reason\n如果 then不是一个function. fulfill promise with x.")])])}),[],!1,null,null,null);r.default=o.exports}}]);